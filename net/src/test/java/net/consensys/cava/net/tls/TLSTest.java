package net.consensys.cava.net.tls;

import static org.junit.jupiter.api.Assertions.assertTrue;

import net.consensys.cava.junit.TempDirectory;
import net.consensys.cava.junit.TempDirectoryExtension;

import java.io.ByteArrayInputStream;
import java.nio.file.Files;
import java.nio.file.Path;
import java.security.KeyFactory;
import java.security.KeyPair;
import java.security.Security;
import java.security.Signature;
import java.security.cert.Certificate;
import java.security.cert.CertificateFactory;
import java.security.spec.PKCS8EncodedKeySpec;
import java.util.concurrent.ThreadLocalRandom;

import org.bouncycastle.jce.provider.BouncyCastleProvider;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;

@ExtendWith(TempDirectoryExtension.class)
class TLSTest {

  @BeforeAll
  static void loadProvider() {
    Security.addProvider(new BouncyCastleProvider());
  }

  @Test
  void createCertificateIfFilesAreNotThere(@TempDirectory Path tempDir) throws Exception {
    Path certificate = tempDir.resolve("foo").resolve("server.crt");
    Path key = tempDir.resolve("foo").resolve("server.key");

    TLS.createSelfSignedCertificateIfMissing(key, certificate);

    assertTrue(Files.exists(key));
    assertTrue(Files.exists(certificate));
  }

  @Test
  void autoGeneratedCertsAreValid(@TempDirectory Path tempDir) throws Exception {
    Path certificate = tempDir.resolve("server.crt");
    Path key = tempDir.resolve("server.key");

    TLS.createSelfSignedCertificateIfMissing(key, certificate);

    checkKeyPair(key, certificate);
  }

  private void checkKeyPair(Path key, Path cert) throws Exception {
    PKCS8EncodedKeySpec pkcs8KeySpec = new PKCS8EncodedKeySpec(SecurityTestUtils.loadPEM(key));
    CertificateFactory cf = CertificateFactory.getInstance("X.509");
    Certificate certificate = cf.generateCertificate(new ByteArrayInputStream(Files.readAllBytes(cert)));
    KeyFactory kf = KeyFactory.getInstance("RSA");
    KeyPair keyPair = new KeyPair(certificate.getPublicKey(), kf.generatePrivate(pkcs8KeySpec));

    byte[] challenge = new byte[10000];
    ThreadLocalRandom.current().nextBytes(challenge);

    // sign using the private key
    Signature sig = Signature.getInstance("SHA256withRSA");
    sig.initSign(keyPair.getPrivate());
    sig.update(challenge);
    byte[] signature = sig.sign();

    // verify signature using the public key
    sig.initVerify(keyPair.getPublic());
    sig.update(challenge);

    assertTrue(sig.verify(signature));
  }
}
