plugins {
  id 'com.diffplug.gradle.spotless' version '3.12.0'
  id 'net.ltgt.errorprone' version '0.0.13'
  id 'io.spring.dependency-management' version '1.0.4.RELEASE'
  id 'com.github.hierynomus.license' version '0.14.0'
  id 'com.jfrog.bintray' version '1.7.3'
  id 'org.jetbrains.kotlin.jvm' version '1.2.41'
}


//////
// Version numbering

def versionNumber = '0.1.0'
def buildVersion = versionNumber + buildTag()

static String buildTag() {
  if (!System.getenv('CIRCLECI')) {
    return '-dev'
  }
  return '-' + System.getenv('CIRCLE_SHA1').take(4).toUpperCase() +
    String.format('%02X', System.getenv('CIRCLE_BUILD_NUM').toInteger() % 256, 16) +
    (System.getenv('BUILD_ENVIRONMENT_TAG') ?: '-snapshot')
}


//////
// Default tasks and build aliases

defaultTasks 'build', 'checkLicenses', 'javadoc'

def buildAliases = ['dev': [
    'spotlessApply',
    'build',
    'checkLicenses',
    'javadoc'
  ]]

def expandedTaskList = []
gradle.startParameter.taskNames.each {
  expandedTaskList << (buildAliases[it] ? buildAliases[it] : it)
}
gradle.startParameter.taskNames = expandedTaskList.flatten()

task deploy() {}

allprojects {
  apply plugin: 'java-library'
  apply plugin: 'kotlin'
  apply plugin: 'com.diffplug.gradle.spotless'
  apply plugin: 'io.spring.dependency-management'
  apply plugin: 'jacoco'
  apply plugin: 'net.ltgt.errorprone'
  apply plugin: 'com.jfrog.bintray'
  apply plugin: 'maven-publish'
  apply from: "${rootDir}/dependency-versions.gradle"
  apply from: "${rootDir}/gradle/check-licenses.gradle"

  version = buildVersion

  repositories { jcenter() }

  //////
  // Use JUnit5 for testing

  test { useJUnitPlatform() { includeEngines 'spek', 'junit-jupiter' } }


  //////
  // Source formatting

  spotless {
    java {
      removeUnusedImports()
      eclipse().configFile(rootProject.file('gradle/eclipse-java-consensys-style.xml'))
      importOrder 'net.consensys', 'java', ''
      endWithNewline()
    }
    groovyGradle {
      target '**/*.gradle'
      greclipse().configFile(rootProject.file('gradle/greclipse-gradle-consensys-style.properties'))
      endWithNewline()
    }
    kotlin {
      ktlint().userData(['indent_size': '2', 'continuation_indent_size' : '2', 'max_line_length': '120'])
      endWithNewline()
    }
  }


  //////
  // Compiler arguments

  tasks.withType(JavaCompile) {
    options.compilerArgs += [
      '-proc:none',
      '-Xlint:unchecked',
      '-Xlint:cast',
      '-Xlint:rawtypes',
      '-Xlint:overloads',
      '-Xlint:divzero',
      '-Xlint:finally',
      '-Xlint:static',
      '-Werror',
      '-Xep:FutureReturnValueIgnored:OFF'
    ]
  }

  tasks.withType(org.jetbrains.kotlin.gradle.tasks.KotlinCompile).all {
    kotlinOptions {
      jvmTarget = "1.8"
      allWarningsAsErrors = true
    }
  }

  afterEvaluate {
    if (project.jar.enabled) {
      task sourcesJar(type: Jar, dependsOn: classes) {
        destinationDir = file("${rootProject.buildDir}/src")
        classifier = 'sources'
        from sourceSets.main.allSource
      }

      task javadocJar(type: Jar, dependsOn: javadoc) {
        destinationDir = file("${rootProject.buildDir}/docs")
        classifier = 'javadoc'
        from javadoc.destinationDir
      }

      jar {
        destinationDir = file("${rootProject.buildDir}/libs")
      }

      tasks.withType(Jar) {
        baseName = rootProject.name + '-' + project.name
        manifest {
          attributes('Implementation-Title': baseName,
          'Implementation-Version': project.version)
        }
      }

      artifacts {
        archives jar
        archives sourcesJar
        archives javadocJar
      }

      publishing {
        publications {
          MavenDeployment(MavenPublication) {
            from components.java
            artifact sourcesJar { classifier 'sources' }
            artifact javadocJar { classifier 'javadoc' }
            groupId 'net.consensys.cava'
            artifactId project.jar.baseName
            version project.version
            pom.withXml {
              def root = asNode()
              root.appendNode('description', project.description)
              root.appendNode('name', project.jar.baseName)
              root.appendNode('url', 'https://github.com/ConsenSys/cava')
              def license = root.appendNode('licenses').appendNode('license')
              license.appendNode('name', 'The Apache Software License, Version 2.0')
              license.appendNode('url', 'http://www.apache.org/licenses/LICENSE-2.0.txt')
              license.appendNode('distribution', 'repo')
              def scm = root.appendNode('scm')
              scm.appendNode('url', 'https://github.com/ConsenSys/cava')
              scm.appendNode('connection', 'scm:https://github.com/ConsenSys/cava.git')
              scm.appendNode('developerConnection', 'scm:git@github.com:ConsenSys/cava.git')
            }
          }
        }
      }

      bintray {
        user = System.getenv('BINTRAY_USER')
        key = System.getenv('BINTRAY_KEY')
        publications = ['MavenDeployment']
        pkg {
          repo = 'consensys'
          name = 'cava'
          userOrg = 'consensys'
          licenses = ['Apache-2.0']
          version {
            name = project.version
            desc = 'Cava distribution'
            released = new Date()
            vcsTag = project.version
          }
        }
      }
      deploy.dependsOn bintrayUpload
    }
  }
}


subprojects {

  //////
  // Parallel build execution

  tasks.withType(Test) {
    // If GRADLE_MAX_TEST_FORKS is not set, use half the available processors
    maxParallelForks = (System.getenv('GRADLE_MAX_TEST_FORKS') ?:
      (Runtime.runtime.availableProcessors().intdiv(2) ?: 1)).toInteger()
  }

  tasks.withType(JavaCompile) {
    options.fork = true
    options.incremental = true
  }

  task allDependencies(type: DependencyReportTask) {}
}


//////
// Bundle all subprojects into a single jar and javadoc

subprojects.each { evaluationDependsOn(it.path) }

jar {
  baseName = rootProject.name
  manifest {
    attributes('Implementation-Title': baseName,
    'Implementation-Version': project.version)
  }

  subprojects.each {
    from it.sourceSets.main.output
    dependsOn it.classes
  }
}

dependencies {
  subprojects.each {
    it.configurations.runtime.allDependencies.each { d ->
      if (d instanceof ExternalModuleDependency) {
        add('runtime', d)
      }
    }
  }
}

javadoc {
  subprojects.each {
    dependsOn it.javadoc
    source += it.javadoc.source
    classpath += it.javadoc.classpath
  }
}

if (!file("eth-reference-tests/src/test/resources/tests/README.md").exists()) {
  throw new GradleException("eth-reference-tests/src/test/resources/tests/README.md missing: please clone submodules (git submodule update --init --recursive)")
}
